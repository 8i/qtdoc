/****************************************************************************
**
** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.  Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: http://www.gnu.org/copyleft/fdl.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\page topics-data-storage.html
\title Data Storage
\brief Qt's data storage features

\section1 Saving and Loading Data

The QIODevice class is the base class for all file and data storage devices
in \l {Qt Core}. All classes that are used for reading and writing data
inherit from it.

Examples of devices are QFile, QBuffer, QTcpSocket, and QProcess.
QFile is used for reading and writing text, binary files, and resources.
The QBuffer class provides a QIODevice interface for a QByteArray.
QTcpSocket enables the developer to establish a TCP connection and transfer
streams of data. QProcess is used to start external programs, and to read
from and write to that process.

\list
\li \l {Input/Output and Networking} (list of I/O related classes)
\li \l {File and Datastream Functions}
\li \l {Serializing Qt Data Types}
\endlist

\section1 SQL support in Qt

The \l {Qt SQL} module uses driver plugins to communicate with several database
APIs. Qt has drivers for SQLite, MYSQL, DB2, Borland InterBase, Oracle, ODBC,
and PostgreSQL. It is also possible to develop your own driver if Qt does not
provide the driver needed.

Qt's SQL classes can be divided in 3 layers:
\table
    \header
        \li Layer
        \li Purpose
        \li Example class
    \row
        \li
            \list
               \li Driver layer
               \li SQL API layer
               \li User Interface layer
            \endlist
        \li
            \list
               \li Low-level communication between database and the SQL API layer
               \li Provide access to databases
               \li Link data from a database to data-aware widgets
            \endlist
        \li
            \list
               \li QSqlDriver, QSqlDriverCreator
               \li QSqlDatabase, QSqlQuery
               \li QSqlQueryModel (readonly), QSqlTableModel (read/write), QSqlRelationalTableModel (read/write with foreign-key support)
            \endlist
\endtable

QSqlQueryModel, QSqlTableModel, and QSqlRelationalTableModel can be used as a
datasource for Qt's classes for viewing data. QSqlTableModel, and
QtSqlRelationalTableModel provide editable models for use with Qt's item views.
QSqlTableModel has read/write access to a single table. QSqlRelationalTableModel
has read/write access to the main table, not to the table where the foreign key
comes from.

With the MYSQL driver, it is possible to connect to a MYSQL server. In order to
build the QMYSQL Plugin for Unix or Mac OS X, you need the MYSQL header files
as well as the shared library libmysqlclient.so. To compile the plugin
for Windows, you need to get the MYSQL installation files and run SETUP.EXE.

If you use the embedded MYSQL Server, you do not need a MYSQL server in order
to use that database system. In order to do so, you need to link the Qt plugin
to libmysqld instead of libmysqlclient.

The Qt SQLite plugin is very suitable for local storage. SQLite is a relational
database management system contained in a small (~350 KiB) C library.
In contrast to other database management systems, SQLite is not a separate process
that is accessed from the client application, but an integral part of it. SQLite
operates on a single file, which must be set as the database name when opening
a connection. If the file does not exist, SQLite will try to create it.

SQLite has some restrictions regarding multiple users and multiple transactions.
If you are reading or writing on a file from different transactions, your
application might freeze until one transaction commits or rolls back.

\list
\li \l {Qt SQL}
\li \l {Qt SQL Module - C++ Classes}
\li \l {Connecting to Databases}
\li \l {SQL Database Drivers}
\li \l {Creating Data-Aware Forms}
\li \l {Using the SQL Model Classes}
\li \l {Presenting Data in a Table View}
\li \l {SQL Programming}
\li \l {Executing SQL Statements}
\li \l {Data Types for Qt-supported Database Systems}
\li \l {Qt Quick Local Storage QML Types}
\endlist

\section1 XML Support in Qt

The QXmlStreamReader class provides a fast parser for reading XML via a simple
streaming API. QXmlStreamReader is a well-formed XML 1.0 parser that does not
include external parsed entities. As long as no error occurs, the application
code can assume that the XML follows \l {W3C XML specifications}.

QXmlStreamReader understands and resolves XML namespaces. For example, in
case of a StartElement, namespaceUri() returns the namespace the element
is in, and name() returns the element's local name. The combination of
namespaceUri() and name() uniquely identifies an element.

QXmlStreamReader does not put a high load on the CPU, since it doesn't store
the entire XML document tree in memory, but only the current token at the time
it is reported.

The QXmlStreamWriter class provides an XML writer with a simple streaming API.
QXmlStreamWriter is the counterpart to QXmlStreamReader for writing XML.
It operates on a QIODevice specified with setDevice(). The API is quite simple:
for every XML token or event you want to write, the writer provides a dedicated
function.

QXmlStreamWriter takes care of prefixing namespaces, all you have to do
is specify the namespaceUri when writing elements or attributes. If you
have to use certain standardized prefixes, you can force the writer to use them
by declaring the namespaces manually with either writeNamespace()
or writeDefaultNamespace().

The stream writer can automatically format the generated XML data by adding
line-breaks and indentation, making the code much more readable. This feature
can be turned on with the auto-formatting property.

By default, QXmlStreamWriter encodes XML in UTF-8. Different encodings can
be enforced using setCodec().

\list
\li \l {An Introduction to Namespaces}
\li \l {Working with the DOM tree}
\li \l {XML Processing}
\li \l {XQuery}
\li \l {The SAX Interface}
\li \l {XML Streaming}
\li \l {XML Classes}
\li \l {A Short Path to XQuery}
\li \l {XmlListModel}
\endlist

\section1 JSON in Qt

JSON is a text-based open standard for data interchange that is easy to read
and parse. It is used for representing simple data structures and associative
arrays, called objects. It is related to JavaScript, but is a language-independent
notation form.

An object can take 2 forms:

\table
    \header
        \list
        \li Collection of name/value pairs
        \li Ordered list of values
        \endlist
    \row
    \li
        \list
        \li
           {
                     "last_name": "Routledge",
                     "first_name": "Ronald",
                     "birth_date": 1960
           }
        \li   "colours": ["green", "blue", "yellow"]
        \endlist
    \li
\endtable

\list
\li \l {JSON Support in Qt}
\endlist

*/
/*
\section1 JavaScript Storage

The Localstorage API provides the ability to access local offline storage in an
 SQL database.

These databases are user-specific and QML-specific, but accessible to all QML
applications. They are stored in the Databases subdirectory of
QDeclarativeEngine::offlineStoragePath(), currently as SQLite databases
(\l {SQL Database Drivers}).

The API conforms to the Synchronous API of the HTML5 Web Database API,
W3C Working Draft 29 October 2009 (\l {HTML5 Web Database API}).

This \l {SQL Local Storage Example} demonstrates the basics of using the Offline
Storage API.

\list
\li \l {Qt Quick Local Storage QML Types}
\endlist

\section1 QSettings

The QSettings class provides persistent storage of application settings.
An application usually remembers its settings from the previous session.
On Windows machines, the settings are often stored in the registry. In
MAC OS X they are stored in XML files. In Unix there is no real standard
for this.

QSettings enable you to save and restore application settings in a portable
manner. Constructing and destroying a QSettings object is leightweight, and
very fast. A simple example of a QSettings object creation: when creating
the object, it is a good practice to specify not only the name of the
application, but also the name of your organization:

\code
   QSettings settings("MyCompany", "Accountancy");
\endcode

\section1 Resources

The Qt Resource System is a platform-independent mechanism for storing binary
files in the application's executable. This is handy if your application
frequently needs a certain file, or set of files. It also protects against
loss of that particular file .

Resource data can either be compiled into the binary and thus accessed
immediately in application code, or a binary resource can be created and at
a later point in application code registered with the resource system.

By default, resources are accessible in the application under the same file
name as they have in the source tree, with a \c{:/} prefix, or by a URL with a
qrc scheme.

\list
\li \l {The Qt Resource System}
\endlist
*/
